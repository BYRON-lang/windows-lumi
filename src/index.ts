import { app, BrowserWindow, ipcMain, shell, dialog } from 'electron';
import Store from 'electron-store';
import * as path from 'path';
import * as fs from 'fs/promises';
import * as http from 'http';
// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// Initialize secure storage
const store = new Store({
  encryptionKey: 'lumi-auth-key-v1' // In production, use a more secure key
});

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit();
}

// Note: Using HTTP callback server instead of protocol registration
// for better cross-platform compatibility and development experience

// Global reference to main window
let mainWindow: BrowserWindow | null = null;
let callbackServer: any = null;
const CALLBACK_PORT = 3948; // Fixed port for auth callback

// Create HTTP server to handle auth callbacks
function createCallbackServer(): void {
  callbackServer = http.createServer();
  
  callbackServer.on('request', (req: any, res: any) => {
    const url = new URL(req.url!, `http://localhost:${CALLBACK_PORT}`);
    
    console.log('HTTP Callback server received request:', {
      method: req.method,
      pathname: url.pathname,
      searchParams: url.searchParams.toString(),
      userAgent: req.headers['user-agent']
    });
    
    // Set CORS headers
    res.setHeader('Access-Control-Allow-Origin', '*');
    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');
    
    if (req.method === 'OPTIONS') {
      res.writeHead(200);
      res.end();
      return;
    }
    
    if (url.pathname === '/auth-callback') {
      const token = url.searchParams.get('token');
      const error = url.searchParams.get('error');
      
      console.log('HTTP Callback processing:', {
        token: token ? 'present' : 'missing',
        error: error || 'none'
      });
      
      // Send success response to browser
      res.writeHead(200, { 'Content-Type': 'text/html' });
      res.end(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>Authentication Complete</title>
          <style>
            body { 
              font-family: system-ui, -apple-system, sans-serif; 
              background: #171717; 
              color: white; 
              display: flex; 
              align-items: center; 
              justify-content: center; 
              height: 100vh; 
              margin: 0;
              text-align: center;
            }
            .container { max-width: 400px; padding: 2rem; }
            .success { color: #4ade80; }
            .error { color: #ef4444; }
            .info { color: #60a5fa; }
          </style>
        </head>
        <body>
          <div class="container">
            <h1>${error ? 'Authentication Failed' : 'Authentication Successful'}</h1>
            <p class="${error ? 'error' : 'success'}">
              ${error ? `Error: ${error}` : 'You can now close this window and return to the Lumi app.'}
            </p>
            <p class="info">Hybrid authentication: HTTP callback method</p>
            <script>
              // Auto-close after 3 seconds
              setTimeout(() => window.close(), 3000);
            </script>
          </div>
        </body>
        </html>
      `);
      
      // Process the auth callback
      if (error) {
        console.error('HTTP Callback auth error:', error);
        if (mainWindow) {
          mainWindow.webContents.send('auth-error', error);
          mainWindow.focus();
        }
      } else if (token) {
        console.log('HTTP Callback auth success, token received');
        handleAuthSuccess(token);
      } else {
        console.log('HTTP Callback: No token or error in callback');
        if (mainWindow) {
          mainWindow.webContents.send('auth-error', 'No token or error in HTTP callback');
          mainWindow.focus();
        }
      }
    } else {
      console.log('HTTP Callback: 404 for path:', url.pathname);
      res.writeHead(404);
      res.end('Not found');
    }
  });
  
  callbackServer.listen(CALLBACK_PORT, 'localhost', () => {
    console.log(`Auth callback server listening on http://localhost:${CALLBACK_PORT}`);
  });
  
  callbackServer.on('error', (err: any) => {
    console.error('Callback server error:', err);
  });
}

// Handle successful authentication
function handleAuthSuccess(token: string): void {
  if (!mainWindow) return;
  
  // Bring window to front
  if (mainWindow.isMinimized()) {
    mainWindow.restore();
  }
  mainWindow.focus();
  
  // Validate token and get user data
  fetch('https://auth-lumi.gridrr.com/auth/me', {
    headers: {
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    }
  })
  .then(response => response.json())
  .then(data => {
    if (data.user) {
      const userData = {
        id: data.user.id,
        email: data.user.email,
        full_name: data.user.fullName || data.user.full_name,
        email_verified: data.user.isVerified || data.user.email_verified
      };
      
      // Store token and user data securely
      store.set('authToken', token);
      store.set('userData', userData);
      
      console.log('Auth success - stored token and user data');
      mainWindow?.webContents.send('auth:callback', token);
    } else {
      mainWindow?.webContents.send('auth-error', 'Invalid user data');
    }
  })
  .catch(err => {
    console.error('Token validation error:', err);
    mainWindow?.webContents.send('auth-error', 'Failed to validate token');
  });
}

const createWindow = (): void => {
  // Create the browser window.
  mainWindow = new BrowserWindow({
    height: 800,
    width: 1280,
    frame: false,
    titleBarStyle: 'hidden',
    resizable: true,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      nodeIntegration: false,
      contextIsolation: true,
      webSecurity: false, // Allow external connections for API calls
      allowRunningInsecureContent: true, // Allow insecure content
    },
  });

  // Allow external connections
  mainWindow.webContents.session.setPermissionRequestHandler((webContents, permission, callback) => {
    if (permission === 'media' || permission === 'geolocation' || permission === 'notifications') {
      callback(false);
    } else {
      callback(true);
    }
  });

  // Set CSP headers to allow external API calls
  mainWindow.webContents.session.webRequest.onHeadersReceived((details, callback) => {
    callback({
      responseHeaders: {
        ...details.responseHeaders,
        'Content-Security-Policy': [
          "default-src * 'unsafe-inline' 'unsafe-eval' data: blob:; connect-src * 'unsafe-inline'; script-src * 'unsafe-inline' 'unsafe-eval'; style-src * 'unsafe-inline';"
        ]
      }
    });
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools in development
  if (process.env.NODE_ENV === 'development') {
    mainWindow.webContents.openDevTools();
  }

  // Handle window closed
  mainWindow.on('closed', () => {
    mainWindow = null;
  });
};


// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  createWindow();
  createCallbackServer();
  
  // Register custom protocol handler for hybrid approach
  // Temporarily disabled for debugging
  // try {
  //   app.setAsDefaultProtocolClient('lumi');
  //   console.log('Protocol handler registered: lumi://');
  // } catch (error) {
  //   console.error('Failed to register protocol handler:', error);
  // }
});

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    // Close callback server
    if (callbackServer) {
      callbackServer.close();
      callbackServer = null;
    }
    app.quit();
  }
});

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

// Prevent multiple instances
const gotTheLock = app.requestSingleInstanceLock();
if (!gotTheLock) {
  app.quit();
} else {
  app.on('second-instance', (event, commandLine, workingDirectory) => {
    // Someone tried to run a second instance, we should focus our window instead
    if (mainWindow) {
      if (mainWindow.isMinimized()) mainWindow.restore();
      mainWindow.focus();
    }
    
    // Handle protocol URL from second instance
    // Temporarily disabled for debugging
    // if (commandLine.length > 1) {
    //   const url = commandLine[commandLine.length - 1];
    //   if (url.startsWith('lumi://')) {
    //     handleProtocolUrl(url);
    //   }
    // }
  });
}

// Handle protocol URLs (for hybrid authentication)
// Temporarily disabled for debugging
// app.on('open-url', (event, url) => {
//   console.log('Protocol URL received:', url);
//   handleProtocolUrl(url);
// });

// Handle protocol URL
function handleProtocolUrl(url: string): void {
  console.log('Handling protocol URL:', url);
  
  if (url.startsWith('lumi://auth-callback')) {
    try {
      const urlObj = new URL(url);
      const token = urlObj.searchParams.get('token');
      const error = urlObj.searchParams.get('error');
      
      console.log('Protocol callback - Token:', token ? 'present' : 'missing', 'Error:', error);
      
      if (error) {
        console.error('Protocol auth error:', error);
        if (mainWindow) {
          mainWindow.webContents.send('auth-error', error);
          mainWindow.focus();
        }
      } else if (token) {
        console.log('Protocol auth success, token received');
        handleAuthSuccess(token);
      } else {
        console.log('No token or error in protocol callback');
        if (mainWindow) {
          mainWindow.webContents.send('auth-error', 'No token or error in protocol callback');
          mainWindow.focus();
        }
      }
    } catch (err) {
      console.error('Error parsing protocol URL:', err);
      if (mainWindow) {
        mainWindow.webContents.send('auth-error', 'Invalid protocol URL');
        mainWindow.focus();
      }
    }
  }
}

// IPC handlers
ipcMain.handle('close-app', () => {
  app.quit();
});

ipcMain.handle('minimize-app', () => {
  const windows = BrowserWindow.getAllWindows();
  if (windows.length > 0) {
    windows[0].minimize();
  }
});

ipcMain.handle('maximize-app', () => {
  const windows = BrowserWindow.getAllWindows();
  if (windows.length > 0) {
    const window = windows[0];
    if (window.isMaximized()) {
      window.unmaximize();
    } else {
      window.maximize();
    }
  }
});

// File system and dialog IPC handlers
ipcMain.handle('dialog:openFile', async () => {
  const result = await dialog.showOpenDialog({
    properties: ['openFile'],
    filters: [
      { name: 'All Files', extensions: ['*'] }
    ]
  });
  return result;
});

ipcMain.handle('dialog:showSaveDialog', async () => {
  const result = await dialog.showSaveDialog({});
  return result;
});

ipcMain.handle('dialog:showOpenDialog', async (event, options) => {
  const result = await dialog.showOpenDialog(options);
  return result;
});

ipcMain.handle('file:write', async (event, filePath: string, content: string) => {
  try {
    await fs.writeFile(filePath, content, 'utf8');
    return { success: true };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('file:read', async (event, filePath: string) => {
  try {
    const content = await fs.readFile(filePath, 'utf8');
    return { success: true, content };
  } catch (error) {
    return { success: false, error: error.message };
  }
});

ipcMain.handle('path:join', async (event, ...paths: string[]) => {
  return path.join(...paths);
});

// Toast notification handler
ipcMain.on('show-toast', (event, { message, type, duration }) => {
  console.log(`Toast [${type}]: ${message}`);
  // In a real implementation, you might want to show a native notification
});

// Auth-related IPC handlers
ipcMain.handle('auth:login', async () => {
  try {
    console.log('Opening Google OAuth URL');
    // Google OAuth URL - uses state parameter to indicate Windows app callback
    const state = encodeURIComponent(JSON.stringify({ platform: 'windows', redirectTo: 'lumi://auth-callback' }));
    const authUrl = `https://auth-lumi.gridrr.com/auth/google?state=${state}`;
    await shell.openExternal(authUrl);
    console.log('Google OAuth URL opened successfully');
  } catch (error) {
    console.error('Error opening Google auth URL:', error);
  }
});

ipcMain.handle('auth:signup', async () => {
  try {
    console.log('Opening email signup URL');
    // Email signup URL for new users - add platform parameter to indicate Windows app
    const authUrl = 'https://lumi.gridrr.com/signup?platform=windows';
    await shell.openExternal(authUrl);
    console.log('Email signup URL opened successfully');
  } catch (error) {
    console.error('Error opening email signup URL:', error);
  }
});

ipcMain.handle('auth:emailLogin', async () => {
  try {
    console.log('Opening email login URL');
    // Email login URL for existing users - add platform parameter to indicate Windows app
    const authUrl = 'https://lumi.gridrr.com/?platform=windows';
    await shell.openExternal(authUrl);
    console.log('Email login URL opened successfully');
  } catch (error) {
    console.error('Error opening email login URL:', error);
  }
});

ipcMain.handle('auth:getToken', async () => {
  try {
    console.log('Getting auth token from store');
    const token = store.get('authToken', null);
    console.log('Retrieved token:', token ? 'exists' : 'null');
    return token;
  } catch (error) {
    console.error('Error getting auth token:', error);
    return null;
  }
});

ipcMain.handle('auth:setToken', async (event, token: string) => {
  try {
    console.log('Setting auth token in store');
    store.set('authToken', token);
    return true;
  } catch (error) {
    console.error('Error setting auth token:', error);
    return false;
  }
});

ipcMain.handle('auth:removeToken', async () => {
  try {
    console.log('Removing auth token and user data from store');
    store.delete('authToken');
    store.delete('userData');
    return true;
  } catch (error) {
    console.error('Error removing auth data:', error);
    return false;
  }
});

ipcMain.handle('auth:getUserData', async () => {
  try {
    console.log('Getting user data from store');
    const userData = store.get('userData', null);
    console.log('Retrieved user data:', userData ? 'exists' : 'null');
    return userData;
  } catch (error) {
    console.error('Error getting user data:', error);
    return null;
  }
});

ipcMain.handle('auth:setUserData', async (event, userData: any) => {
  try {
    console.log('Setting user data in store');
    store.set('userData', userData);
    return true;
  } catch (error) {
    console.error('Error setting user data:', error);
    return false;
  }
});

// In this file you can include the rest of your app's specific main process
// code. You can also put them in separate files and import them here.
